<!doctype html>

<html lang="pl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>GrowCastle â€” prosty klon</title>
<style>
  :root{--bg:#0d47a1;--panel:#ffffffdd}
  html,body{height:100%;margin:0;font-family:Inter, system-ui, Roboto, Arial}
  body{background:linear-gradient(#4fc3f7,#0d47a1);display:flex;align-items:center;justify-content:center;padding:18px}
  .wrap{width:1100px;max-width:100%;display:grid;grid-template-columns:720px 1fr;gap:16px}
  canvas{width:100%;height:680px;background:transparent;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
  .panel{background:var(--panel);border-radius:12px;padding:12px;box-shadow:0 6px 20px rgba(0,0,0,.12)}
  h2{margin:4px 0 8px}
  .stats{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:8px}
  .stat{background:#ffffffcc;padding:8px;border-radius:8px;font-weight:700}
  .shop .item{display:flex;align-items:center;justify-content:space-between;padding:8px;border-radius:8px;margin-bottom:8px;background:#ffffffcc}
  button{cursor:pointer;padding:8px 12px;border-radius:8px;border:none;background:#0d47a1;color:white;font-weight:700}
  .small{padding:6px 8px;font-size:14px}
  footer{font-size:12px;color:#333;margin-top:8px}
  .note{font-size:13px;color:#222}
</style>
</head>
<body>
  <div class="wrap">
    <div style="position:relative">
      <canvas id="game" width="720" height="680"></canvas>
    </div><div class="panel shop">
  <h2>GrowCastle (wersja uproszczona)</h2>
  <div class="stats">
    <div class="stat">ZÅ‚oto: <span id="gold">100</span></div>
    <div class="stat">Zamek: <span id="castleHp">20</span></div>
    <div class="stat">Fala: <span id="wave">0</span></div>
    <div class="stat">XP: <span id="xp">0</span></div>
  </div>

  <h3>Sklep</h3>
  <div class="item">
    <div>WieÅ¼a StrzaÅ‚ ğŸ”°<br><small>Tanio, strzaÅ‚y</small></div>
    <div>
      <div>Koszt: 30</div>
      <button id="buy-arch">Kup</button>
    </div>
  </div>
  <div class="item">
    <div>WieÅ¼a Mag ğŸ”®<br><small>WiÄ™cej damage</small></div>
    <div>
      <div>Koszt: 60</div>
      <button id="buy-mage">Kup</button>
    </div>
  </div>
  <div class="item">
    <div>WieÅ¼yczka MaÅ‚a ğŸ›¡ï¸<br><small>Staje siÄ™ barierÄ…</small></div>
    <div>
      <div>Koszt: 20</div>
      <button id="buy-block">Kup</button>
    </div>
  </div>

  <h3>Sterowanie</h3>
  <p class="note">Kliknij kafelek na mapie, aby postawiÄ‡ zakupionÄ… wieÅ¼yczkÄ™ (nie moÅ¼esz stawiaÄ‡ na torze spawnu). KupujÄ…c wieÅ¼Ä™ jej koszt jest od razu pobierany.</p>
  <div style="display:flex;gap:8px;margin-top:8px">
    <button id="startWave">Start Fali</button>
    <button id="upgrade-hero">Ulepsz Bohatera (50)</button>
  </div>

  <div style="margin-top:12px">
    <h3>Bohater ğŸ—¡ï¸</h3>
    <div class="note">Twoja gÅ‚Ã³wna jednostka stoi przy zamku. Ma poziom, atakuje natarcia i daje premie.</div>
  </div>

  <footer>
    Grafika: tylko emotkami â€” potwory ğŸ‘¾, wieÅ¼e ğŸ”°/ğŸ”®, bohater ğŸ—¡ï¸, zamek ğŸ°.
  </footer>
</div>

  </div><script>
/* GrowCastle â€” prosty klon: 3 pasy, spawny z lewej, zamek po prawej. Emotkigrafika. */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const TILE = 40; const COLS = Math.floor(canvas.width / TILE); const ROWS = Math.floor(canvas.height / TILE);
// pasy: ustalamy trzy rzÄ™dy Å›cieÅ¼ek
const lanes = [ Math.floor(ROWS*0.25), Math.floor(ROWS*0.5), Math.floor(ROWS*0.75) ];

let gold = 100, castleHp = 20, wave = 0, xp = 0;
document.getElementById('gold').innerText = gold; document.getElementById('castleHp').innerText = castleHp; document.getElementById('wave').innerText = wave; document.getElementById('xp').innerText = xp;

const towerTypes = {
  arch: {emoji:'ğŸ”°', cost:30, range:120, rate:0.9, damage:1},
  mage: {emoji:'ğŸ”®', cost:60, range:140, rate:1.4, damage:3},
  block: {emoji:'ğŸ›¡ï¸', cost:20, range:0, rate:0, damage:0, block:true}
};
let selected = null; // type purchased to place

// hero
let hero = {emoji:'ğŸ—¡ï¸', level:1, dmg:2, xpForNext:100};

// game objects
const towers = []; // {x,y,type,cooldown}
const enemies = []; // {lane,pos,hp,speed,type}

// spawn config
function spawnEnemyForWave(w){ const baseCount = 5 + w*2; for(let i=0;i<baseCount;i++){ const delay = i*700; setTimeout(()=>{
    const lane = lanes[Math.floor(Math.random()*lanes.length)];
    const typeRoll = Math.random();
    const hp = 2 + Math.floor(w*0.8) + (typeRoll>0.85?4:0);
    const speed = 0.4 + w*0.02 + (typeRoll>0.85? -0.05 : 0);
    enemies.push({lane:lane, pos:0, hp:hp, speed:speed, type:'basic'});
  }, delay);
 }
}

// buy buttons
document.getElementById('buy-arch').onclick = ()=>{ if(gold>=towerTypes.arch.cost){ gold -= towerTypes.arch.cost; selected='arch'; updateUI(); } }
document.getElementById('buy-mage').onclick = ()=>{ if(gold>=towerTypes.mage.cost){ gold -= towerTypes.mage.cost; selected='mage'; updateUI(); } }
document.getElementById('buy-block').onclick = ()=>{ if(gold>=towerTypes.block.cost){ gold -= towerTypes.block.cost; selected='block'; updateUI(); } }

document.getElementById('startWave').onclick = ()=>{ if(!playing) startWave(); }
document.getElementById('upgrade-hero').onclick = ()=>{ if(gold>=50){ gold-=50; hero.level++; hero.dmg += 1; hero.xpForNext = Math.floor(hero.xpForNext*1.5); updateUI(); } }

function updateUI(){ document.getElementById('gold').innerText = gold; document.getElementById('castleHp').innerText = castleHp; document.getElementById('wave').innerText = wave; document.getElementById('xp').innerText = xp; }

// place tower on click
canvas.addEventListener('click',(ev)=>{
  const rect = canvas.getBoundingClientRect(); const x = ev.clientX - rect.left; const y = ev.clientY - rect.top; const cx = Math.floor(x/TILE); const cy = Math.floor(y/TILE);
  // don't allow placing on far right column (castle zone) or on lanes path (spawn path left to right)
  const castleCol = COLS-1;
  if(cx >= castleCol) return;
  // if selected
  if(selected){ // don't place on lane tiles (where centers align)
    // allow blocks anywhere non-lane
    const isOnLane = lanes.includes(cy);
    if(isOnLane && towerTypes[selected].block !== true) return; // arch/mage allowed on lane center only? For simplicity require placing near lane center
    // ensure no tower exists there
    if(towers.some(t=>t.x===cx && t.y===cy)) { selected=null; updateUI(); return; }
    towers.push({x:cx,y:cy,type:selected,cooldown:0}); selected=null; updateUI();
  }
});

let playing=false;
function startWave(){ wave++; updateUI(); playing=true; spawnEnemyForWave(wave); // end check
  // allow playing until all enemies died
  const checkEnd = setInterval(()=>{ if(enemies.length===0){ playing=false; clearInterval(checkEnd); } }, 500);
}

// game loop
let last = performance.now();
function tick(delta){ // move enemies
  const dt = delta*0.06;
  for(let e of enemies){ e.pos += e.speed * dt; }
  // check reach castle
  for(let i=enemies.length-1;i>=0;i--){ const e = enemies[i]; if(e.pos >= COLS-1){ castleHp -= 1; enemies.splice(i,1); if(castleHp<=0){ alert('PrzegraÅ‚eÅ› â€” zamek zniszczony!'); resetGame(); return; } updateUI(); } }
  // towers shoot
  for(let t of towers){ const tt = towerTypes[t.type]; if(tt.block) continue; t.cooldown -= dt; if(t.cooldown <= 0){ // find enemy in range
      const tx = t.x*TILE + TILE/2; const ty = t.y*TILE + TILE/2;
      let targetIdx = -1; let best = 1e9;
      for(let i=0;i<enemies.length;i++){ const e = enemies[i]; const ex = Math.min(Math.floor(e.pos), COLS-1) * TILE + TILE/2; const ey = e.lane * TILE + TILE/2; const d = Math.hypot(ex-tx, ey-ty); if(d <= tt.range && d < best){ best=d; targetIdx=i; } }
      if(targetIdx>=0){ enemies[targetIdx].hp -= tt.damage; t.cooldown = tt.rate; if(enemies[targetIdx].hp <= 0){ // kill
          gold += 10 + Math.floor(wave*1.2); xp += 10; enemies.splice(targetIdx,1); updateUI(); levelCheck(); }
      }
    }
  }
  // hero attack: hits closest enemy near castle
  if(hero){ // hero attacks every tick by cooldown simulated via simple timer
    hero._cd = (hero._cd || 0) - dt;
    if(hero._cd <= 0){ // find nearest enemy on any lane with pos near castle
      let bestDist = -1; let idx = -1;
      for(let i=0;i<enemies.length;i++){ const e = enemies[i]; const dist = (COLS-1) - e.pos; if(idx===-1 || dist < bestDist){ bestDist = dist; idx = i; } }
      if(idx>=0 && bestDist < 6){ enemies[idx].hp -= hero.dmg; hero._cd = 0.6; if(enemies[idx].hp <=0){ gold += 12; xp += 12; enemies.splice(idx,1); updateUI(); levelCheck(); } }
    }
  }
}

function levelCheck(){ if(xp >= hero.xpForNext){ xp -= hero.xpForNext; hero.level++; hero.dmg += 1; hero.xpForNext = Math.floor(hero.xpForNext * 1.6); updateUI(); } }

function resetGame(){ gold=100; castleHp=20; wave=0; xp=0; enemies.length=0; towers.length=0; hero = {emoji:'ğŸ—¡ï¸', level:1, dmg:2, xpForNext:100}; updateUI(); }

// draw
function draw(){ ctx.clearRect(0,0,canvas.width,canvas.height);
  // background sky with faint clouds
  ctx.fillStyle = 'rgba(255,255,255,0.06)';
  for(let i=0;i<6;i++){ ctx.font = '32px serif'; ctx.fillText('â˜ï¸', 40 + i*110, 40 + (i*45)%160); }
  // ground
  ctx.fillStyle = '#2e7d32'; ctx.fillRect(0, ROWS*TILE - TILE*2, canvas.width, TILE*2);

  // lanes path (horizontal)
  ctx.strokeStyle = '#00000020'; ctx.lineWidth = 2;
  for(let lane of lanes){ for(let c=0;c<COLS;c++){ ctx.fillStyle = '#cfae8a33'; ctx.fillRect(c*TILE, lane*TILE, TILE, TILE); ctx.strokeRect(c*TILE, lane*TILE, TILE, TILE); } }

  // castle on right
  const castleX = (COLS-1)*TILE + TILE/2; const castleY = Math.floor(ROWS/2)*TILE + TILE/2;
  ctx.font = '44px serif'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('ğŸ°', castleX, castleY);

  // towers
  ctx.font = '28px serif';
  for(let t of towers){ ctx.fillText(towerTypes[t.type].emoji, t.x*TILE + TILE/2, t.y*TILE + TILE/2); }

  // enemies
  ctx.font = '28px serif';
  for(let e of enemies){ const ex = Math.min(e.pos, COLS-1) * TILE + TILE/2; const ey = e.lane * TILE + TILE/2; ctx.fillText('ğŸ‘¾', ex, ey); // hp bar
    const barW = TILE-6; ctx.fillStyle='red'; ctx.fillRect(ex - barW/2, ey - TILE/2 + 6, Math.max(0, (e.hp/6)) * barW, 6); ctx.strokeStyle='black'; ctx.strokeRect(ex - barW/2, ey - TILE/2 + 6, barW,6);
  }

  // hero near castle (below)
  ctx.fillText(hero.emoji + ' Lv'+hero.level, castleX, castleY + 60);

  // selected preview
  if(selected){ canvas.style.cursor='crosshair'; } else canvas.style.cursor='default';
}

// main loop
let then = performance.now(); function loop(now){ const delta = now - then; then = now; tick(delta); draw(); requestAnimationFrame(loop); }
requestAnimationFrame(loop);
</script></body>
</html>
